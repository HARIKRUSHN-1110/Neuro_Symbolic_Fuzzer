# src/generators/atomic_behaviors.py
# This file was only used for testing purpose to see what happens as if the sceanrio was generated by behaviors using specific classes
from scenariogeneration import xosc

class AtomicBehavior:
    """Base class for all maneuvers"""
    def get_maneuver(self, actor_name: str) -> xosc.Maneuver:
        raise NotImplementedError

class CutInManeuver(AtomicBehavior):
    def __init__(self, target_lane, duration=2.0, start_time=2.0):
        self.target_lane = target_lane
        self.duration = duration
        self.start_time = start_time

    def get_maneuver(self, actor_name: str) -> xosc.Maneuver:
        maneuver = xosc.Maneuver(f"{actor_name}_CutIn")
        event = xosc.Event(f"{actor_name}_LaneChange", xosc.Priority.override)
        
        # Action: Change Lane
        action = xosc.AbsoluteLaneChangeAction(
            self.target_lane, 
            xosc.TransitionDynamics(xosc.DynamicsShapes.sinusoidal, xosc.DynamicsDimension.time, self.duration)
        )
        event.add_action("LaneChangeAction", action)
        
        # Trigger: Time
        trigger = xosc.ValueTrigger(
            f"{actor_name}_Trigger", 0, xosc.ConditionEdge.rising, 
            xosc.SimulationTimeCondition(self.start_time, xosc.Rule.greaterThan)
        )
        event.add_trigger(trigger)
        maneuver.add_event(event)
        return maneuver

class EmergencyBrakeManeuver(AtomicBehavior):
    def __init__(self, target_speed=0, duration=3.0, trigger_distance=20, trigger_entity="Target"):
        self.target_speed = target_speed
        self.duration = duration
        self.trigger_distance = trigger_distance
        self.trigger_entity = trigger_entity

    def get_maneuver(self, actor_name: str) -> xosc.Maneuver:
        maneuver = xosc.Maneuver(f"{actor_name}_EmergencyBrake")
        event = xosc.Event(f"{actor_name}_BrakeEvent", xosc.Priority.override)
        
        # Action: Brake
        action = xosc.AbsoluteSpeedAction(
            self.target_speed, 
            xosc.TransitionDynamics(xosc.DynamicsShapes.linear, xosc.DynamicsDimension.time, self.duration)
        )
        event.add_action("BrakeAction", action)
        
        # Trigger: Distance (EntityTrigger)
        cond = xosc.RelativeDistanceCondition(
            self.trigger_distance, xosc.Rule.lessThan, entity=self.trigger_entity, 
            dist_type=xosc.RelativeDistanceType.longitudinal, coordinate_system=xosc.CoordinateSystem.entity
        )
        trigger = xosc.EntityTrigger(f"{actor_name}_DistTrigger", 0, xosc.ConditionEdge.rising, cond, triggerentity=actor_name)
        event.add_trigger(trigger)
        maneuver.add_event(event)
        return maneuver

class ResumeSpeedManeuver(AtomicBehavior):
    def __init__(self, target_speed=50, trigger_dist=30, trigger_entity="Target"):
        self.target_speed = target_speed
        self.trigger_dist = trigger_dist
        self.trigger_entity = trigger_entity

    def get_maneuver(self, actor_name: str) -> xosc.Maneuver:
        maneuver = xosc.Maneuver(f"{actor_name}_ResumeSpeed")
        event = xosc.Event(f"{actor_name}_ResumeEvent", xosc.Priority.override)
        
        action = xosc.AbsoluteSpeedAction(
            self.target_speed / 3.6, 
            xosc.TransitionDynamics(xosc.DynamicsShapes.sinusoidal, xosc.DynamicsDimension.time, 5.0)
        )
        event.add_action("ResumeAction", action)
        
        cond = xosc.RelativeDistanceCondition(
            self.trigger_dist, xosc.Rule.greaterThan, entity=self.trigger_entity, 
            dist_type=xosc.RelativeDistanceType.longitudinal, coordinate_system=xosc.CoordinateSystem.entity
        )
        # Time guard to prevent instant trigger
        time_cond = xosc.SimulationTimeCondition(5.0, xosc.Rule.greaterThan)
        
        trigger = xosc.EntityTrigger(f"{actor_name}_SafeGapTrigger", 0, xosc.ConditionEdge.rising, cond, triggerentity=actor_name)
        time_trigger = xosc.ValueTrigger("TimeGuard", 0, xosc.ConditionEdge.none, time_cond)
        
        event.add_trigger(trigger)
        event.add_trigger(time_trigger)
        maneuver.add_event(event)
        return maneuver

class OvertakeManeuver(AtomicBehavior):
    def __init__(self, target_lane, trigger_dist=25, trigger_entity="Target"):
        self.target_lane = target_lane
        self.trigger_dist = trigger_dist
        self.trigger_entity = trigger_entity

    def get_maneuver(self, actor_name: str) -> xosc.Maneuver:
        maneuver = xosc.Maneuver(f"{actor_name}_Overtake")
        event = xosc.Event(f"{actor_name}_OvertakeEvent", xosc.Priority.override)
        
        action = xosc.AbsoluteLaneChangeAction(
            self.target_lane, 
            xosc.TransitionDynamics(xosc.DynamicsShapes.sinusoidal, xosc.DynamicsDimension.time, 3.0)
        )
        event.add_action("LaneChangeAction", action)
        
        cond = xosc.RelativeDistanceCondition(
            self.trigger_dist, xosc.Rule.lessThan, entity=self.trigger_entity, 
            dist_type=xosc.RelativeDistanceType.longitudinal, coordinate_system=xosc.CoordinateSystem.entity
        )
        time_cond = xosc.SimulationTimeCondition(8.0, xosc.Rule.greaterThan)

        trigger = xosc.EntityTrigger(f"{actor_name}_OvertakeTrigger", 0, xosc.ConditionEdge.rising, cond, triggerentity=actor_name)
        time_trigger = xosc.ValueTrigger("TimeGuard", 0, xosc.ConditionEdge.none, time_cond)
        
        event.add_trigger(trigger)
        event.add_trigger(time_trigger)
        maneuver.add_event(event)
        return maneuver

class KeepSpeedManeuver(AtomicBehavior):
    def __init__(self, speed_kmph):
        self.speed = speed_kmph / 3.6

    def get_maneuver(self, actor_name: str) -> xosc.Maneuver:
        maneuver = xosc.Maneuver(f"{actor_name}_KeepSpeed")
        event = xosc.Event(f"{actor_name}_Drive", xosc.Priority.override)
        action = xosc.AbsoluteSpeedAction(self.speed, xosc.TransitionDynamics(xosc.DynamicsShapes.step, xosc.DynamicsDimension.time, 0))
        event.add_action("DriveAction", action)
        trigger = xosc.ValueTrigger(f"{actor_name}_StartTrigger", 0, xosc.ConditionEdge.none, xosc.SimulationTimeCondition(0, xosc.Rule.greaterThan))
        event.add_trigger(trigger)
        maneuver.add_event(event)
        return maneuver